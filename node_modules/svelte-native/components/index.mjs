import { SvelteComponent, init, safe_not_equal, create_slot, get_slot_changes, get_slot_context, transition_in, transition_out, assign, exclude_internal_props, noop, binding_callbacks, bind, space, set_attributes, insert, mount_component, get_spread_update, detach, destroy_component, add_flush_callback } from 'svelte/internal';

/* src\components\SlotComponent.svelte generated by Svelte v3.12.1 */

const get_default_slot_changes = ({ p }) => ({ props: p });
const get_default_slot_context = ({ p }) => ({ props: p });

function create_fragment(ctx) {
	var current;

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, get_default_slot_context);

	return {
		c() {
			if (default_slot) default_slot.c();
		},

		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},

		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && (changed.$$scope || changed.p)) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, get_default_slot_changes),
					get_slot_context(default_slot_template, ctx, get_default_slot_context)
				);
			}
		},

		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots = {}, $$scope } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('$$scope' in $$new_props) $$invalidate('$$scope', $$scope = $$new_props.$$scope);
	};

	let p;

	$$self.$$.update = ($$dirty = { $$props: 1 }) => {
		$$invalidate('p', p = $$props);
	};

	return {
		p,
		$$props: $$props = exclude_internal_props($$props),
		$$slots,
		$$scope
	};
}

class SlotComponent extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, []);
	}
}

/* src\components\AsComponent.svelte generated by Svelte v3.12.1 */

function create_fragment$1(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

function instance$1($$self, $$props, $$invalidate) {
	//copy our slot content and scope
    let slots = $$props.$$slots;
    let scope = $$props.$$scope;

    let { component = class extends SlotComponent {
        constructor(options) {
            //force instances of this component to use our slot content and scope.
            let new_options = Object.assign({}, options);
            new_options.props = Object.assign({}, options.props, { $$slots: slots, $$scope: scope });
            super(new_options);
        }
    } } = $$props;

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('component' in $$new_props) $$invalidate('component', component = $$new_props.component);
	};

	return {
		component,
		$$props: $$props = exclude_internal_props($$props)
	};
}

class AsComponent extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, ["component"]);
	}
}

/* src\components\Template.svelte generated by Svelte v3.12.1 */

const get_default_slot_changes$1 = ({ props }) => ({ item: props });
const get_default_slot_context$1 = ({ props }) => ({ item: (props ? props.item : null) });

// (2:0) <AsComponent bind:component="{template}" let:props>
function create_default_slot(ctx) {
	var current;

	const default_slot_template = ctx.$$slots.default;
	const default_slot = create_slot(default_slot_template, ctx, get_default_slot_context$1);

	return {
		c() {
			if (default_slot) default_slot.c();
		},

		l(nodes) {
			if (default_slot) default_slot.l(nodes);
		},

		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},

		p(changed, ctx) {
			if (default_slot && default_slot.p && (changed.$$scope || changed.props)) {
				default_slot.p(
					get_slot_changes(default_slot_template, ctx, changed, get_default_slot_changes$1),
					get_slot_context(default_slot_template, ctx, get_default_slot_context$1)
				);
			}
		},

		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},

		o(local) {
			transition_out(default_slot, local);
			current = false;
		},

		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment$2(ctx) {
	var template_1, t, updating_component, current;

	var template_1_levels = [
		ctx.$$props,
		{ component: ctx.template },
		{ xmlns: "tns" }
	];

	var template_1_data = {};
	for (var i = 0; i < template_1_levels.length; i += 1) {
		template_1_data = assign(template_1_data, template_1_levels[i]);
	}

	function ascomponent_component_binding(value) {
		ctx.ascomponent_component_binding.call(null, value);
		updating_component = true;
		add_flush_callback(() => updating_component = false);
	}

	let ascomponent_props = {
		$$slots: {
		default: [create_default_slot, ({ props }) => ({ props })]
	},
		$$scope: { ctx }
	};
	if (ctx.template !== void 0) {
		ascomponent_props.component = ctx.template;
	}
	var ascomponent = new AsComponent({ props: ascomponent_props });

	binding_callbacks.push(() => bind(ascomponent, 'component', ascomponent_component_binding));

	return {
		c() {
			template_1 = document.createElementNS("tns", "template");
			t = space();
			ascomponent.$$.fragment.c();
			set_attributes(template_1, template_1_data);
		},

		m(target, anchor) {
			insert(target, template_1, anchor);
			insert(target, t, anchor);
			mount_component(ascomponent, target, anchor);
			current = true;
		},

		p(changed, ctx) {
			set_attributes(template_1, get_spread_update(template_1_levels, [
				(changed.$$props) && ctx.$$props,
				(changed.template) && { component: ctx.template },
				{ xmlns: "tns" }
			]));

			var ascomponent_changes = {};
			if (changed.$$scope) ascomponent_changes.$$scope = { changed, ctx };
			if (!updating_component && changed.template) {
				ascomponent_changes.component = ctx.template;
			}
			ascomponent.$set(ascomponent_changes);
		},

		i(local) {
			if (current) return;
			transition_in(ascomponent.$$.fragment, local);

			current = true;
		},

		o(local) {
			transition_out(ascomponent.$$.fragment, local);
			current = false;
		},

		d(detaching) {
			if (detaching) {
				detach(template_1);
				detach(t);
			}

			destroy_component(ascomponent, detaching);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let template;

	let { $$slots = {}, $$scope } = $$props;

	function ascomponent_component_binding(value) {
		template = value;
		$$invalidate('template', template);
	}

	$$self.$set = $$new_props => {
		$$invalidate('$$props', $$props = assign(assign({}, $$props), $$new_props));
		if ('$$scope' in $$new_props) $$invalidate('$$scope', $$scope = $$new_props.$$scope);
	};

	return {
		template,
		$$props,
		ascomponent_component_binding,
		$$props: $$props = exclude_internal_props($$props),
		$$slots,
		$$scope
	};
}

class Template extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, []);
	}
}

export { Template };
