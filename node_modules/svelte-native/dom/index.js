'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var frame = require('tns-core-modules/ui/frame');
var application = require('tns-core-modules/application');
var page = require('tns-core-modules/ui/page');
var keyframeAnimation = require('tns-core-modules/ui/animation/keyframe-animation');
var cssAnimationParser = require('tns-core-modules/ui/styling/css-animation-parser');
var layoutBase = require('tns-core-modules/ui/layouts/layout-base');
var observableArray = require('tns-core-modules/data/observable-array/observable-array');
var listView = require('tns-core-modules/ui/list-view');
var tabView = require('tns-core-modules/ui/tab-view');
var tabContentItem = require('tns-core-modules/ui/tab-navigation-base/tab-content-item');
var bottomNavigation = require('tns-core-modules/ui/bottom-navigation');
var tabs = require('tns-core-modules/ui/tabs');
var actionBar = require('tns-core-modules/ui/action-bar');
var tabStrip = require('tns-core-modules/ui/tab-navigation-base/tab-strip');
var tabStripItem = require('tns-core-modules/ui/tab-navigation-base/tab-strip-item');
var trace = require('tns-core-modules/trace');

(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
})(exports.LogLevel || (exports.LogLevel = {}));
const nullLogger = () => { };
class Logger {
    constructor() {
        this.onLog = () => nullLogger;
    }
    setHandler(logger) {
        this.onLog = logger || nullLogger;
    }
    debug(message) {
        this.onLog(message, exports.LogLevel.Debug);
    }
    info(message) {
        this.onLog(message, exports.LogLevel.Info);
    }
    warn(message) {
        this.onLog(message, exports.LogLevel.Warn);
    }
    error(message) {
        this.onLog(message, exports.LogLevel.Error);
    }
}
const logger = new Logger();

const dashRegExp = /-/g;
function normalizeElementName(elementName) {
    return `${elementName
        .replace(dashRegExp, '')
        .toLowerCase()}`;
}
function* elementIterator(el) {
    yield el;
    for (let child of el.childNodes) {
        yield* elementIterator(child);
    }
}
class ViewNode {
    constructor() {
        this.nodeType = null;
        this._tagName = null;
        this.parentNode = null;
        this.childNodes = [];
        this.prevSibling = null;
        this.nextSibling = null;
        this._ownerDocument = null;
        this._attributes = {};
    }
    hasAttribute(name) {
        return Object.keys(this._attributes).indexOf(name) > -1;
    }
    removeAttribute(name) {
        delete this._attributes[name];
    }
    /* istanbul ignore next */
    toString() {
        return `${this.constructor.name}(${this.tagName})`;
    }
    set tagName(name) {
        this._tagName = normalizeElementName(name);
    }
    get tagName() {
        return this._tagName;
    }
    get firstChild() {
        return this.childNodes.length ? this.childNodes[0] : null;
    }
    get lastChild() {
        return this.childNodes.length
            ? this.childNodes[this.childNodes.length - 1]
            : null;
    }
    /* istanbul ignore next */
    get ownerDocument() {
        if (this._ownerDocument) {
            return this._ownerDocument;
        }
        let el = this;
        while (el != null && el.nodeType !== 9) {
            el = el.parentNode;
        }
        return (this._ownerDocument = el);
    }
    getAttribute(key) {
        return this._attributes[key];
    }
    /* istanbul ignore next */
    setAttribute(key, value) {
        this._attributes[key] = value;
    }
    /* istanbul ignore next */
    setText(text) {
        logger.debug(`setText ${this} ${text}`);
        if (this.nodeType === 3) {
            this.parentNode.setText(text);
        }
        else {
            this.setAttribute('text', text);
        }
    }
    onInsertedChild(childNode, index) { }
    onRemovedChild(childNode) { }
    insertBefore(childNode, referenceNode) {
        logger.debug(`insert before ${this} ${childNode} ${referenceNode}`);
        if (!childNode) {
            throw new Error(`Can't insert child.`);
        }
        // in some rare cases insertBefore is called with a null referenceNode
        // this makes sure that it get's appended as the last child
        if (!referenceNode) {
            return this.appendChild(childNode);
        }
        if (referenceNode.parentNode !== this) {
            throw new Error(`Can't insert child, because the reference node has a different parent.`);
        }
        if (childNode.parentNode && childNode.parentNode !== this) {
            throw new Error(`Can't insert child, because it already has a different parent.`);
        }
        if (childNode.parentNode === this) ;
        let index = this.childNodes.indexOf(referenceNode);
        childNode.parentNode = this;
        childNode.nextSibling = referenceNode;
        childNode.prevSibling = this.childNodes[index - 1];
        referenceNode.prevSibling = childNode;
        this.childNodes.splice(index, 0, childNode);
        this.onInsertedChild(childNode, index);
    }
    appendChild(childNode) {
        logger.debug(`append child ${this} ${childNode}`);
        if (!childNode) {
            throw new Error(`Can't append child.`);
        }
        if (childNode.parentNode && childNode.parentNode !== this) {
            throw new Error(`Can't append child, because it already has a different parent.`);
        }
        if (childNode.parentNode === this) ;
        childNode.parentNode = this;
        if (this.lastChild) {
            childNode.prevSibling = this.lastChild;
            this.lastChild.nextSibling = childNode;
        }
        this.childNodes.push(childNode);
        this.onInsertedChild(childNode, this.childNodes.length - 1);
    }
    removeChild(childNode) {
        logger.debug(`remove child ${this} ${childNode}`);
        if (!childNode) {
            throw new Error(`Can't remove child.`);
        }
        if (!childNode.parentNode) {
            throw new Error(`Can't remove child, because it has no parent.`);
        }
        if (childNode.parentNode !== this) {
            throw new Error(`Can't remove child, because it has a different parent.`);
        }
        childNode.parentNode = null;
        if (childNode.prevSibling) {
            childNode.prevSibling.nextSibling = childNode.nextSibling;
        }
        if (childNode.nextSibling) {
            childNode.nextSibling.prevSibling = childNode.prevSibling;
        }
        // reset the prevSibling and nextSibling. If not, a keep-alived component will
        // still have a filled nextSibling attribute so vue will not
        // insert the node again to the parent. See #220
        childNode.prevSibling = null;
        childNode.nextSibling = null;
        this.childNodes = this.childNodes.filter(node => node !== childNode);
        this.onRemovedChild(childNode);
    }
    firstElement() {
        for (var child of this.childNodes) {
            if (child.nodeType == 1) {
                return child;
            }
        }
        return null;
    }
}

class ElementNode extends ViewNode {
    constructor(tagName) {
        super();
        this.nodeType = 1;
        this.tagName = tagName;
    }
    get id() {
        return this.getAttribute('id');
    }
    set id(value) {
        this.setAttribute('id', value);
    }
    get classList() {
        if (!this._classList) {
            const getClasses = () => (this.getAttribute('class') || "").split(/\s+/).filter((k) => k != "");
            this._classList = {
                add: (...classNames) => {
                    this.setAttribute('class', [...new Set(getClasses().concat(classNames))].join(" "));
                },
                remove: (...classNames) => {
                    this.setAttribute('class', getClasses().filter((i) => classNames.indexOf(i) == -1).join(" "));
                },
                get length() {
                    return getClasses().length;
                }
            };
        }
        return this._classList;
    }
    appendChild(childNode) {
        super.appendChild(childNode);
        if (childNode.nodeType === 3) {
            this.setText(childNode.text);
        }
        if (childNode.nodeType === 7) {
            childNode.setOnNode(this);
        }
    }
    insertBefore(childNode, referenceNode) {
        super.insertBefore(childNode, referenceNode);
        if (childNode.nodeType === 3) {
            this.setText(childNode.text);
        }
        if (childNode.nodeType === 7) {
            childNode.setOnNode(this);
        }
    }
    removeChild(childNode) {
        super.removeChild(childNode);
        if (childNode.nodeType === 3) {
            this.setText('');
        }
        if (childNode.nodeType === 7) {
            childNode.clearOnNode(this);
        }
    }
}

class CommentNode extends ElementNode {
    constructor(text) {
        super('comment');
        this.nodeType = 8;
        this.text = text;
    }
}

class TextNode extends ViewNode {
    constructor(text) {
        super();
        this.nodeType = 3;
        this.text = text;
    }
    setText(text) {
        this.text = text;
        this.parentNode.setText(text);
    }
    set data(text) {
        this.setText(text);
    }
    get data() {
        return this.text;
    }
}

class PropertyNode extends ElementNode {
    constructor(tagName, propertyName) {
        super(`${tagName}.${propertyName}`);
        this.propertyName = propertyName;
        this.propertyTagName = normalizeElementName(tagName);
        this.nodeType = 7; //processing instruction
    }
    onInsertedChild() {
        this.setOnNode(this.parentNode);
    }
    onRemovedChild() {
        this.setOnNode(this.parentNode);
    }
    /* istanbul ignore next */
    toString() {
        return `${this.constructor.name}(${this.tagName}, ${this.propertyName})`;
    }
    setOnNode(parent) {
        if (parent && (parent.tagName === this.propertyTagName)) {
            const el = this.firstElement();
            parent.setAttribute(this.propertyName, el);
        }
    }
    clearOnNode(parent) {
        if (parent && (parent.tagName === this.propertyTagName)) {
            parent.setAttribute(this.propertyName, null);
        }
    }
}

const elementMap = {};
function registerElementResolver(elementName, entry) {
    const normalizedName = normalizeElementName(elementName);
    if (elementMap[normalizedName]) {
        throw new Error(`Element for ${normalizedName} already registered.`);
    }
    elementMap[normalizedName] = entry;
}
function registerElement(elementName, resolver) {
    registerElementResolver(elementName, { resolver: resolver });
}
function createElement(elementName) {
    const normalizedName = normalizeElementName(elementName);
    const elementDefinition = elementMap[normalizedName];
    if (!elementDefinition) {
        throw new TypeError(`No known component for element ${elementName}.`);
    }
    return elementDefinition.resolver();
}

class DocumentNode extends ViewNode {
    constructor() {
        super();
        this.tagName = "docNode";
        this.nodeType = 9;
    }
    createComment(text) {
        return new CommentNode(text);
    }
    createPropertyNode(tagName, propertyName) {
        return new PropertyNode(tagName, propertyName);
    }
    createElement(tagName) {
        if (tagName.indexOf(".") >= 0) {
            let bits = tagName.split(".", 2);
            return this.createPropertyNode(bits[0], bits[1]);
        }
        return createElement(tagName);
    }
    createElementNS(namespace, tagName) {
        return this.createElement(tagName);
    }
    createTextNode(text) {
        return new TextNode(text);
    }
    getElementById(id) {
        for (let el of elementIterator(this)) {
            if (el.nodeType === 1 && el.id === id)
                return el;
        }
    }
    dispatchEvent(event) {
        //Svelte dev fires these for tool support
    }
}

class StyleSheet {
    constructor() {
        this._rules = [];
    }
    // The css rules generated by svelte have a keyframe every 16 milliseconds and are quite slow to create and run
    // this is here to support the simple and short ones, but ideally we would promote our own transitions in svelte-native/transitions
    // which would delegate to the more direct nativescript way of working.
    deleteRule(index) {
        let removed = this._rules.splice(index, 1);
        for (let r in removed) {
            logger.debug(`removing transition rule ${r}`);
            // Turns out nativescript doesn't support "removing" css.
            // this is pretty horrible but better than a memory leak. 
            // since this code is called mainly for keyframes, and keyframes don't add new selectors (they just end up in _keyframes)
            // we can almost remove the rules ourselves.
            if (r.startsWith('@keyframes')) {
                const name = r.split(" ")[1];
                let frame$1 = frame.topmost();
                if (frame$1 && frame$1._styleScope) {
                    let scope = frame$1._styleScope;
                    delete scope._keyframes[name];
                    scope._css = scope._css.replace(r, "");
                }
            }
        }
    }
    insertRule(rule, index = 0) {
        logger.debug(`Adding transition rule ${rule}`);
        let frame$1 = frame.topmost();
        frame$1.addCss(rule);
        this._rules.splice(index, 0, rule);
    }
    get cssRules() {
        return this._rules;
    }
}
class StyleElement extends ElementNode {
    constructor() {
        super('style');
        this._sheet = new StyleSheet();
    }
    get sheet() {
        return this._sheet;
    }
}

class HeadElement extends ElementNode {
    constructor() {
        super('head');
    }
    onInsertedChild(childNode, atIndex) {
        if (childNode instanceof StyleElement) {
            let css = childNode.textContent;
            let id = childNode.id;
            let style_hash = id.replace('-style', '');
            //style rules are one per line as long as each selector in the rule has the style hash we are all scoped styles and can pass true to addCss
            let all_scoped = css.split("\n").every(r => r.split(",").every(i => i.indexOf(style_hash) >= 0));
            if (css) {
                application.addCss(css, all_scoped);
            }
        }
    }
}

class TemplateElement extends ElementNode {
    constructor() {
        super('template');
    }
    set component(value) {
        this.setAttribute('component', value);
    }
    get component() {
        return this.getAttribute('component');
    }
}

// Dom elements that svelte expects to be able to create or use.
// or custom additions to make life easier
function registerSvelteElements() {
    registerElement('head', () => new HeadElement());
    registerElement('style', () => new StyleElement());
    registerElement('fragment', () => new ElementNode('fragment'));
    registerElement('template', () => new TemplateElement());
}

(function (NativeElementPropType) {
    NativeElementPropType[NativeElementPropType["Value"] = 0] = "Value";
    NativeElementPropType[NativeElementPropType["Array"] = 1] = "Array";
    NativeElementPropType[NativeElementPropType["ObservableArray"] = 2] = "ObservableArray";
})(exports.NativeElementPropType || (exports.NativeElementPropType = {}));
function setOnArrayProp(parent, value, propName, build = null) {
    let current = parent[propName];
    if (!current || !current.push) {
        parent[propName] = build ? build(value) : [value];
    }
    else {
        current.push(value);
    }
}
function removeFromArrayProp(parent, value, propName) {
    let current = parent[propName];
    if (!current || !current.splice) {
        let idx = current.indexOf(value);
        if (idx >= 0)
            current.splice(idx, 1);
    }
}
const _normalizedKeys = new Map();
function getNormalizedKeysForObject(obj, knownPropNames) {
    let proto = Object.getPrototypeOf(obj);
    let m = _normalizedKeys.get(proto);
    if (m)
        return m;
    //calculate our prop names
    let props = new Map();
    _normalizedKeys.set(proto, props);
    //include known props
    knownPropNames.forEach(p => props.set(p.toLowerCase(), p));
    //infer the rest from the passed object (including updating any incorrect known prop names if found)
    for (let p in obj) {
        props.set(p.toLowerCase(), p);
    }
    return props;
}
function normalizeKeyFromObject(obj, key) {
    let lowerkey = key.toLowerCase();
    for (let p in obj) {
        if (p.toLowerCase() == lowerkey) {
            return p;
        }
    }
    return key;
}
// Implements an ElementNode that wraps a NativeScript object. It uses the object as the source of truth for its attributes
class NativeElementNode extends ElementNode {
    constructor(tagName, elementClass, setsParentProp = null, propConfig = {}) {
        super(tagName);
        this.propAttribute = null;
        this.propConfig = propConfig;
        this.propAttribute = setsParentProp;
        this._nativeElement = new elementClass();
        this._normalizedKeys = getNormalizedKeysForObject(this._nativeElement, Object.keys(this.propConfig));
        this._nativeElement.__SvelteNativeElement__ = this;
        logger.debug(`created ${this} ${this._nativeElement}`);
    }
    get nativeElement() {
        return this._nativeElement;
    }
    set nativeElement(el) {
        if (this._nativeElement) {
            throw new Error(`Can't overwrite native element.`);
        }
        this._nativeElement = el;
    }
    getAttribute(fullkey) {
        let getTarget = this.nativeElement;
        let keypath = fullkey.split(".");
        let resolvedKeys = [];
        while (keypath.length > 0) {
            if (!getTarget)
                return null;
            let key = keypath.shift();
            if (resolvedKeys.length == 0) {
                key = this._normalizedKeys.get(key) || key;
            }
            else {
                key = normalizeKeyFromObject(getTarget, key);
            }
            resolvedKeys.push(key);
            if (keypath.length > 0) {
                getTarget = getTarget[key];
            }
            else {
                return getTarget[key];
            }
        }
        return null;
    }
    onInsertedChild(childNode, index) {
        super.onInsertedChild(childNode, index);
        // support for the prop: shorthand for setting parent property to native element
        if (!(childNode instanceof NativeElementNode))
            return;
        let propName = childNode.propAttribute;
        if (!propName)
            return;
        //Special case Array and Observable Array keys
        propName = this._normalizedKeys.get(propName) || propName;
        switch (this.propConfig[propName]) {
            case exports.NativeElementPropType.Array:
                setOnArrayProp(this.nativeElement, childNode.nativeElement, propName);
                return;
            case exports.NativeElementPropType.ObservableArray:
                setOnArrayProp(this.nativeElement, childNode.nativeElement, propName, (v) => new observableArray.ObservableArray(v));
                return;
            default:
                this.setAttribute(propName, childNode);
        }
    }
    onRemovedChild(childNode) {
        if (!(childNode instanceof NativeElementNode))
            return;
        let propName = childNode.propAttribute;
        if (!propName)
            return;
        //Special case Array and Observable Array keys
        propName = this._normalizedKeys.get(propName) || propName;
        switch (this.propConfig[propName]) {
            case exports.NativeElementPropType.Array:
            case exports.NativeElementPropType.ObservableArray:
                removeFromArrayProp(this.nativeElement, childNode, propName);
                return;
            default:
                this.setAttribute(propName, null);
        }
        super.onRemovedChild(childNode);
    }
    setAttribute(fullkey, value) {
        const nv = this.nativeElement;
        let setTarget = nv;
        // normalize key
        if (page.isAndroid && fullkey.startsWith('android:')) {
            fullkey = fullkey.substr(8);
        }
        if (page.isIOS && fullkey.startsWith('ios:')) {
            fullkey = fullkey.substr(4);
        }
        if (fullkey.startsWith("prop:")) {
            this.propAttribute = fullkey.substr(5);
            return;
        }
        //we might be getting an element from a propertyNode eg page.actionBar, unwrap
        if (value instanceof NativeElementNode) {
            value = value.nativeElement;
        }
        let keypath = fullkey.split(".");
        let resolvedKeys = [];
        while (keypath.length > 0) {
            if (!setTarget)
                return;
            let key = keypath.shift();
            // normalize to correct case
            if (resolvedKeys.length == 0) {
                key = this._normalizedKeys.get(key) || key;
            }
            else {
                key = normalizeKeyFromObject(setTarget, key);
            }
            resolvedKeys.push(key);
            if (keypath.length > 0) {
                setTarget = setTarget[key];
            }
            else {
                try {
                    logger.debug(`setAttr value ${this} ${resolvedKeys.join(".")} ${value}`);
                    setTarget[key] = value;
                }
                catch (e) {
                    // ignore but log
                    logger.error(`set attribute threw an error, attr:${key} on ${this._tagName}: ${e.message}`);
                }
            }
        }
    }
}
function registerNativeConfigElement(elementName, resolver, parentProp = null, propConfig = {}) {
    registerElement(elementName, () => new NativeElementNode(elementName, resolver(), parentProp, propConfig));
}

function camelize(kebab) {
    return kebab.replace(/[\-]+(\w)/g, (m, l) => l.toUpperCase());
}
function registerNativeViewElement(elementName, resolver, parentProp = null, propConfig = {}) {
    registerElement(elementName, () => new NativeViewElementNode(elementName, resolver(), parentProp, propConfig));
}
// A NativeViewElementNode, wraps a native View and handles style, event dispatch, and native view hierarchy management.
class NativeViewElementNode extends NativeElementNode {
    constructor(tagName, viewClass, setsParentProp = null, propConfig = {}) {
        super(tagName, viewClass, setsParentProp, propConfig);
        let setStyleAttribute = (value) => {
            this.setAttribute('style', value);
        };
        let getStyleAttribute = () => {
            return this.getAttribute('style');
        };
        let getParentPage = () => {
            if (this.nativeView && this.nativeView.page) {
                return this.nativeView.page.__SvelteNativeElement__;
            }
            return null;
        };
        let animations = new Map();
        let oldAnimations = [];
        const addAnimation = (animation) => {
            logger.debug(`Adding animation ${animation}`);
            if (!this.nativeView) {
                throw Error("Attempt to apply animation to tag without a native view" + this.tagName);
            }
            let page = getParentPage();
            if (page == null) {
                animations.set(animation, null);
                return;
            }
            //quickly cancel any old ones
            while (oldAnimations.length) {
                let oldAnimation = oldAnimations.shift();
                if (oldAnimation.isPlaying) {
                    oldAnimation.cancel();
                }
            }
            //Parse our "animation" style property into an animation info instance (this won't include the keyframes from the css)
            let animationInfos = cssAnimationParser.CssAnimationParser.keyframeAnimationsFromCSSDeclarations([{ property: "animation", value: animation }]);
            if (!animationInfos) {
                animations.set(animation, null);
                return;
            }
            let animationInfo = animationInfos[0];
            //Fetch an animationInfo instance that includes the keyframes from the css (this won't include the animation properties parsed above)
            let animationWithKeyframes = page.nativeView.getKeyframeAnimationWithName(animationInfo.name);
            if (!animationWithKeyframes) {
                animations.set(animation, null);
                return;
            }
            animationInfo.keyframes = animationWithKeyframes.keyframes;
            //combine the keyframes from the css with the animation from the parsed attribute to get a complete animationInfo object
            let animationInstance = keyframeAnimation.KeyframeAnimation.keyframeAnimationFromInfo(animationInfo);
            // save and launch the animation
            animations.set(animation, animationInstance);
            animationInstance.play(this.nativeView);
        };
        const removeAnimation = (animation) => {
            logger.debug(`Removing animation ${animation}`);
            if (animations.has(animation)) {
                let animationInstance = animations.get(animation);
                animations.delete(animation);
                if (animationInstance) {
                    if (animationInstance.isPlaying) {
                        //we don't want to stop right away since svelte removes the animation before it is finished due to our lag time starting the animation.
                        oldAnimations.push(animationInstance);
                    }
                }
            }
        };
        this.style = {
            setProperty: (propertyName, value, priority) => {
                this.setStyle(camelize(propertyName), value);
            },
            removeProperty: (propertyName) => {
                this.setStyle(camelize(propertyName), null);
            },
            get animation() {
                return [...animations.keys()].join(", ");
            },
            set animation(value) {
                logger.debug(`setting animation ${value}`);
                let new_animations = value.trim() == "" ? [] : value.split(',').map(a => a.trim());
                //add new ones
                for (let anim of new_animations) {
                    if (!animations.has(anim)) {
                        addAnimation(anim);
                    }
                }
                //remove old ones
                for (let anim of animations.keys()) {
                    if (new_animations.indexOf(anim) < 0) {
                        removeAnimation(anim);
                    }
                }
            },
            get cssText() {
                logger.debug("got css text");
                return getStyleAttribute();
            },
            set cssText(value) {
                logger.debug("set css text");
                setStyleAttribute(value);
            }
        };
    }
    /* istanbul ignore next */
    setStyle(property, value) {
        logger.debug(`setStyle ${this} ${property} ${value}`);
        if (!(value = value.toString().trim()).length) {
            return;
        }
        if (property.endsWith('Align')) {
            // NativeScript uses Alignment instead of Align, this ensures that text-align works
            property += 'ment';
        }
        this.nativeView.style[property] = value;
    }
    get nativeView() {
        return this.nativeElement;
    }
    set nativeView(view) {
        this.nativeElement = view;
    }
    /* istanbul ignore next */
    addEventListener(event, handler) {
        logger.debug(`add event listener ${this} ${event}`);
        this.nativeView.on(event, handler);
    }
    /* istanbul ignore next */
    removeEventListener(event, handler) {
        logger.debug(`remove event listener ${this} ${event}`);
        this.nativeView.off(event, handler);
    }
    onInsertedChild(childNode, index) {
        super.onInsertedChild(childNode, index);
        if (!(childNode instanceof NativeViewElementNode)) {
            return;
        }
        //if we are a property value, then skip adding to parent
        if (childNode.propAttribute)
            return;
        const parentView = this.nativeView;
        const childView = childNode.nativeView;
        if (!parentView || !childView) {
            return;
        }
        //use the builder logic if we aren't being dynamic, to catch config items like <actionbar> that are not likely to be toggled
        if (index < 0 && parentView._addChildFromBuilder) {
            parentView._addChildFromBuilder(childView.constructor.name, childView);
            return;
        }
        if (parentView instanceof layoutBase.LayoutBase) {
            if (index >= 0) {
                //our dom includes "textNode" and "commentNode" which does not appear in the nativeview's children. 
                //we recalculate the index required for the insert operation by only including native view element nodes in the count
                //that aren't property setter nodes
                let nativeIndex = this.childNodes.filter(e => e instanceof NativeViewElementNode && !e.propAttribute).indexOf(childNode);
                parentView.insertChild(childView, nativeIndex);
            }
            else {
                parentView.addChild(childView);
            }
            return;
        }
        // we aren't a layout view, but we were given an index, try the _addChildFromBuilder first
        if (parentView._addChildFromBuilder) {
            return parentView._addChildFromBuilder(childView.constructor.name, childView);
        }
        if (parentView instanceof page.ContentView) {
            parentView.content = childView;
            return;
        }
        throw new Error("Parent can't contain children: " + this + ", " + childNode);
    }
    onRemovedChild(childNode) {
        super.onRemovedChild(childNode);
        if (!(childNode instanceof NativeViewElementNode)) {
            return;
        }
        //childnodes with propAttributes aren't added to native views
        if (childNode.propAttribute)
            return;
        if (!this.nativeView || !childNode.nativeView) {
            return;
        }
        const parentView = this.nativeView;
        const childView = childNode.nativeView;
        if (parentView instanceof layoutBase.LayoutBase) {
            parentView.removeChild(childView);
        }
        else if (parentView instanceof page.ContentView) {
            if (parentView.content === childView) {
                parentView.content = null;
            }
            if (childNode.nodeType === 8) {
                parentView._removeView(childView);
            }
        }
        else if (parentView instanceof page.View) {
            parentView._removeView(childView);
        }
        else {
            logger.warn("Unknown parent view type: " + parentView);
        }
    }
    dispatchEvent(event) {
        if (this.nativeView) {
            //nativescript uses the EventName while dom uses Type
            event.eventName = event.type;
            this.nativeView.notify(event);
        }
    }
}

class PageElement extends NativeViewElementNode {
    constructor() {
        super('page', page.Page);
    }
}

class FrameElement extends NativeViewElementNode {
    constructor() {
        super('frame', frame.Frame);
    }
    setAttribute(key, value) {
        if (key.toLowerCase() == "defaultpage") {
            logger.debug(`loading page ${value}`);
            let dummy = createElement('fragment');
            let page = new value({ target: dummy, props: {} });
            this.nativeView.navigate({ create: () => dummy.firstElement().nativeView });
            return;
        }
        super.setAttribute(key, value);
    }
    //In regular native script, Frame elements aren't meant to have children, we instead allow it to have one.. a page.. as a convenience
    // and set the instance as the default page by navigating to it.
    onInsertedChild(childNode, index) {
        //only handle page nodes
        if (!(childNode instanceof PageElement))
            return;
        this.nativeView.navigate({ create: () => childNode.nativeView });
    }
}

class SvelteKeyedTemplate {
    constructor(key, templateEl) {
        this._key = key;
        this._templateEl = templateEl;
    }
    get component() {
        return this._templateEl.component;
    }
    get key() {
        return this._key;
    }
    createView() {
        //create a proxy element to eventually contain our item (once we have one to render)
        //TODO is StackLayout the best choice here? 
        logger.debug(`creating view for key ${this.key}`);
        let wrapper = createElement('StackLayout');
        wrapper.setStyle("padding", 0);
        wrapper.setStyle("margin", 0);
        let nativeEl = wrapper.nativeView;
        nativeEl.__SvelteComponentBuilder__ = (props) => {
            let instance = new this.component({
                target: wrapper,
                props: props
            });
            nativeEl.__SvelteComponent__ = instance;
        };
        return nativeEl;
    }
}
class ListViewElement extends NativeViewElementNode {
    constructor() {
        super('listview', listView.ListView);
        this.nativeView.on(listView.ListView.itemLoadingEvent, (args) => { this.updateListItem(args); });
    }
    updateListItem(args) {
        let item;
        let listView = this.nativeView;
        let items = listView.items;
        if (args.index >= items.length) {
            logger.error(`Got request for item at index that didn't exist ${args.index}`);
            return;
        }
        if (items.getItem) {
            item = items.getItem(args.index);
        }
        else {
            item = items[args.index];
        }
        if (!args.view || !args.view.__SvelteComponent__) {
            let component;
            if (args.view && args.view.__SvelteComponentBuilder__) {
                logger.debug(`instantiating component in keyed view item at ${args.index}`);
                //now we have an item, we can create and mount this component
                args.view.__SvelteComponentBuilder__({ item });
                args.view.__SvelteComponentBuilder__ = null; //free the memory
                return;
            }
            logger.debug(`creating default view for item at ${args.index}`);
            if (typeof listView.itemTemplates == "object") {
                component = listView.itemTemplates.filter(x => x.key == "default").map(x => x.component)[0];
            }
            if (!component) {
                logger.error(`Couldn't determine component to use for item at ${args.index}`);
                return;
            }
            let wrapper = createElement('ProxyViewContainer');
            let componentInstance = new component({
                target: wrapper,
                props: {
                    item
                }
            });
            let nativeEl = wrapper.nativeView;
            nativeEl.__SvelteComponent__ = componentInstance;
            args.view = nativeEl;
        }
        else {
            let componentInstance = args.view.__SvelteComponent__;
            logger.debug(`updating view for ${args.index} which is a ${args.view}`);
            componentInstance.$set({ item });
        }
    }
    onInsertedChild(childNode, index) {
        super.onInsertedChild(childNode, index);
        if (childNode instanceof TemplateElement) {
            let key = childNode.getAttribute('key') || "default";
            logger.debug(`Adding template for key ${key}`);
            if (!this.nativeView.itemTemplates || typeof this.nativeView.itemTemplates == "string") {
                this.nativeView.itemTemplates = [];
            }
            this.nativeView.itemTemplates.push(new SvelteKeyedTemplate(key, childNode));
        }
    }
    onRemovedChild(childNode) {
        super.onRemovedChild(childNode);
        if (childNode instanceof TemplateElement) {
            let key = childNode.getAttribute('key') || "default";
            if (this.nativeView.itemTemplates && typeof this.nativeView.itemTemplates != "string") {
                this.nativeView.itemTemplates = this.nativeView.itemTemplates.filter(t => t.key != key);
            }
        }
    }
}

class TabViewElement extends NativeViewElementNode {
    constructor() {
        super('TabView', tabView.TabView);
        this.needs_update = false;
    }
    doUpdate() {
        let items = this.childNodes.filter(x => x instanceof NativeViewElementNode && x.nativeView instanceof tabView.TabViewItem).map(x => x.nativeView);
        logger.debug(`updating tab items. now has ${items.length} items`);
        this.nativeView.items = items;
    }
    onInsertedChild(childNode, index) {
        try {
            //We only want to handle TabViewItem and only if it is the last item!
            if (!(childNode instanceof NativeViewElementNode && childNode.nativeView instanceof tabView.TabViewItem))
                return super.onInsertedChild(childNode, index);
            this.needs_update = true;
            //resolve after this event loop to catch all added tabviewitems in one update, and to handle the fact that svelte adds the
            //tabviewitem to tabview while it is still empty which causes problems.
            Promise.resolve().then(() => {
                if (this.needs_update) {
                    this.doUpdate();
                    this.needs_update = false;
                }
            }).catch(e => console.error(e));
        }
        catch (e) {
            console.error(e);
        }
    }
    onRemovedChild(childNode) {
        if (!(childNode instanceof NativeViewElementNode && childNode.nativeView instanceof tabView.TabViewItem))
            return super.onRemovedChild(childNode);
        console.error("Removing a TabViewItem is not supported atm see:  https://github.com/NativeScript/nativescript-angular/issues/621");
    }
}

class BaseTabNavigationElement extends NativeViewElementNode {
    constructor(tagName, viewClass) {
        super(tagName, viewClass);
    }
    onInsertedChild(childNode, index) {
        try {
            if (childNode instanceof NativeViewElementNode && childNode.nativeView instanceof tabContentItem.TabContentItem) {
                logger.debug(`adding tab content to nav`);
                let item = childNode.nativeView;
                //wait for next turn so that any content for our tab is attached to the dom
                Promise.resolve().then(() => {
                    let items = (this.nativeView.items || []).concat([item]);
                    this.nativeView.items = [];
                    this.nativeView.items = items;
                });
                return;
            }
        }
        catch (e) {
            console.error(e);
        }
        super.onInsertedChild(childNode, index);
    }
    onRemovedChild(childNode) {
        try {
            if (childNode instanceof NativeViewElementNode && childNode.nativeView instanceof tabContentItem.TabContentItem) {
                logger.debug(`removing content item from nav`);
                let items = (this.nativeView.items || []).filter(i => i != childNode.nativeView);
                this.nativeView.items = [];
                this.nativeView.items = items;
                return;
            }
        }
        catch (e) {
            console.error(e);
        }
        super.onRemovedChild(childNode);
    }
}

class BottomNavigationElement extends BaseTabNavigationElement {
    constructor() {
        super("BottomNavigation", bottomNavigation.BottomNavigation);
    }
}

class TabsElement extends BaseTabNavigationElement {
    constructor() {
        super("Tabs", tabs.Tabs);
    }
}

class ActionBarElement extends NativeViewElementNode {
    constructor() {
        super('ActionBar', actionBar.ActionBar);
    }
    onInsertedChild(childNode, index) {
        //ActionItems isn't an array or ObservableArray, it is a special ActionItems type, so we handle it here
        if (childNode instanceof NativeElementNode) {
            let propName = childNode.propAttribute;
            if (propName) {
                propName = this._normalizedKeys.get(propName) || propName;
                if (propName.toLowerCase() == "actionitems") {
                    this.nativeView.actionItems.addItem(childNode.nativeElement);
                    return; //skip rest of the processing.
                }
            }
        }
        super.onInsertedChild(childNode, index);
    }
    onRemovedChild(childNode) {
        if (childNode instanceof NativeElementNode) {
            let propName = childNode.propAttribute;
            if (propName) {
                propName = this._normalizedKeys.get(propName) || propName;
                if (propName.toLowerCase() == "actionitems") {
                    this.nativeView.actionItems.removeItem(childNode.nativeElement);
                    return; //skip rest of the processing.
                }
            }
        }
        super.onRemovedChild(childNode);
    }
}

class TabStripElement extends NativeViewElementNode {
    constructor() {
        super("TabStrip", tabStrip.TabStrip, null);
    }
    onInsertedChild(childNode, index) {
        // As of tns-core-modules 6.1.2 setting a new array here doesn't set the parent property of any new tabstripitems
        // and causes a crash. a workaround suggested https://github.com/NativeScript/NativeScript/issues/7608
        // is to set items to [] before setting it to the new array.
        try {
            if (childNode instanceof NativeViewElementNode && childNode.nativeView instanceof tabStripItem.TabStripItem) {
                logger.debug(`adding tab strip item ${childNode.nativeView.title}`);
                const items = this.nativeView.items || [];
                this.nativeView.items = [];
                this.nativeView.items = items.concat([childNode.nativeView]);
                return;
            }
        }
        catch (e) {
            console.error(e);
        }
        super.onInsertedChild(childNode, index);
    }
    onRemovedChild(childNode) {
        try {
            if (childNode instanceof NativeViewElementNode && childNode.nativeView instanceof tabStripItem.TabStripItem) {
                logger.debug(`removing tab strip item ${childNode.nativeView.title}`);
                let items = (this.nativeView.items || []).filter(i => i != childNode.nativeView);
                this.nativeView.items = [];
                this.nativeView.items = items;
            }
        }
        catch (e) {
            console.error(e);
        }
        super.onRemovedChild(childNode);
    }
}

function registerNativeElements() {
    registerNativeViewElement('ActionItem', () => require('tns-core-modules/ui/action-bar').ActionItem, 'actionItems');
    registerNativeViewElement('NavigationButton', () => require('tns-core-modules/ui/action-bar').NavigationButton, 'navigationButton');
    registerNativeViewElement('TabViewItem', () => require('tns-core-modules/ui/tab-view').TabViewItem);
    // NS components which uses the automatic registerElement Vue wrapper
    // as they do not need any special logic
    registerNativeViewElement('Label', () => require('tns-core-modules/ui/label').Label);
    registerNativeViewElement('DatePicker', () => require('tns-core-modules/ui/date-picker').DatePicker);
    registerNativeViewElement('AbsoluteLayout', () => require('tns-core-modules/ui/layouts/absolute-layout').AbsoluteLayout);
    registerNativeViewElement('ActivityIndicator', () => require('tns-core-modules/ui/activity-indicator').ActivityIndicator);
    registerNativeViewElement('Border', () => require('tns-core-modules/ui/border').Border);
    registerNativeViewElement('Button', () => require('tns-core-modules/ui/button').Button);
    registerNativeViewElement('ContentView', () => require('tns-core-modules/ui/content-view').ContentView);
    registerNativeViewElement('DockLayout', () => require('tns-core-modules/ui/layouts/dock-layout').DockLayout);
    registerNativeViewElement('GridLayout', () => require('tns-core-modules/ui/layouts/grid-layout').GridLayout);
    registerNativeViewElement('HtmlView', () => require('tns-core-modules/ui/html-view').HtmlView);
    registerNativeViewElement('Image', () => require('tns-core-modules/ui/image').Image);
    registerNativeViewElement('ListPicker', () => require('tns-core-modules/ui/list-picker').ListPicker);
    registerNativeViewElement('Placeholder', () => require('tns-core-modules/ui/placeholder').Placeholder);
    registerNativeViewElement('Progress', () => require('tns-core-modules/ui/progress').Progress);
    registerNativeViewElement('ProxyViewContainer', () => require('tns-core-modules/ui/proxy-view-container').ProxyViewContainer);
    // registerElement(
    //   'Repeater',
    //   () => require('tns-core-modules/ui/repeater').Repeater
    // )
    registerNativeViewElement('ScrollView', () => require('tns-core-modules/ui/scroll-view').ScrollView);
    registerNativeViewElement('SearchBar', () => require('tns-core-modules/ui/search-bar').SearchBar);
    registerNativeViewElement('SegmentedBar', () => require('tns-core-modules/ui/segmented-bar').SegmentedBar, null, { "items": exports.NativeElementPropType.Array });
    registerNativeViewElement('SegmentedBarItem', () => require('tns-core-modules/ui/segmented-bar').SegmentedBarItem, "items");
    registerNativeViewElement('Slider', () => require('tns-core-modules/ui/slider').Slider);
    registerNativeViewElement('StackLayout', () => require('tns-core-modules/ui/layouts/stack-layout').StackLayout);
    registerNativeViewElement('FlexboxLayout', () => require('tns-core-modules/ui/layouts/flexbox-layout').FlexboxLayout);
    registerNativeViewElement('Switch', () => require('tns-core-modules/ui/switch').Switch);
    registerNativeViewElement('TextField', () => require('tns-core-modules/ui/text-field').TextField);
    registerNativeViewElement('TextView', () => require('tns-core-modules/ui/text-view').TextView);
    registerNativeViewElement('TimePicker', () => require('tns-core-modules/ui/time-picker').TimePicker);
    registerNativeViewElement('WebView', () => require('tns-core-modules/ui/web-view').WebView);
    registerNativeViewElement('WrapLayout', () => require('tns-core-modules/ui/layouts/wrap-layout').WrapLayout);
    registerNativeViewElement('FormattedString', () => require('tns-core-modules/text/formatted-string').FormattedString);
    registerNativeViewElement('Span', () => require('tns-core-modules/text/span').Span);
    registerElement('ActionBar', () => new ActionBarElement());
    registerElement('Frame', () => new FrameElement());
    registerElement('Page', () => new PageElement());
    registerElement('ListView', () => new ListViewElement());
    registerElement('TabView', () => new TabViewElement());
    registerElement('BottomNavigation', () => new BottomNavigationElement());
    registerElement('Tabs', () => new TabsElement());
    registerElement('TabStrip', () => new TabStripElement());
    registerNativeViewElement('TabStripItem', () => require('tns-core-modules/ui/tab-navigation-base/tab-strip-item').TabStripItem);
    registerNativeViewElement('TabContentItem', () => require('tns-core-modules/ui/tab-navigation-base/tab-content-item').TabContentItem);
}

class SvelteNativeDocument extends DocumentNode {
    constructor() {
        super();
        this.head = createElement('head');
        this.appendChild(this.head);
        logger.debug(`created ${this}`);
    }
    createTextNode(text) {
        const el = new TextNode(text);
        logger.debug(`created ${el}`);
        return el;
    }
    createElementNS(namespace, tagName) {
        return this.createElement(tagName);
    }
    createEvent(type) {
        let e = {};
        e.initCustomEvent = (type, ignored1, ignored2, detail) => {
            e.type = type;
            e.detail = detail;
            e.eventName = type;
        };
        return e;
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function resolveFrame(frameSpec) {
    let targetFrame;
    if (!frameSpec)
        targetFrame = frame.topmost();
    if (frameSpec instanceof FrameElement)
        targetFrame = frameSpec.nativeView;
    if (frameSpec instanceof frame.Frame)
        targetFrame = frameSpec;
    if (typeof frameSpec == "string") {
        targetFrame = frame.getFrameById(frameSpec);
        if (!targetFrame)
            logger.error(`Navigate could not find frame with id ${frameSpec}`);
    }
    return targetFrame;
}
function resolveComponentElement(pageSpec, props) {
    let dummy = createElement('fragment');
    let pageInstance = new pageSpec({ target: dummy, props: props });
    let element = dummy.firstElement();
    return { element, pageInstance };
}
function navigate(options) {
    let { frame, page, props = {} } = options, navOptions = __rest(options, ["frame", "page", "props"]);
    let targetFrame = resolveFrame(frame);
    if (!targetFrame) {
        throw new Error("navigate requires frame option to be a native Frame, a FrameElement, a frame Id, or null");
    }
    if (!page) {
        throw new Error("navigate requires page to be set to the svelte component class that implements the page or reference to a page element");
    }
    let { element, pageInstance } = resolveComponentElement(page, props);
    if (!(element instanceof PageElement))
        throw new Error("navigate requires a svelte component with a page element at the root");
    let nativePage = element.nativeView;
    const handler = (args) => {
        if (args.isBackNavigation) {
            nativePage.off('navigatedFrom', handler);
            pageInstance.$destroy();
        }
    };
    nativePage.on('navigatedFrom', handler);
    targetFrame.navigate(Object.assign({}, navOptions, { create: () => nativePage }));
    return pageInstance;
}
function goBack(options = {}) {
    let targetFrame = resolveFrame(options.frame);
    if (!targetFrame) {
        throw new Error("goback requires frame option to be a native Frame, a FrameElement, a frame Id, or null");
    }
    let backStackEntry = null;
    if (options.to) {
        backStackEntry = targetFrame.backStack.find(e => e.resolvedPage === options.to.nativeView);
        if (!backStackEntry) {
            throw new Error("Couldn't find the destination page in the frames backstack");
        }
    }
    return targetFrame.goBack(backStackEntry);
}
const modalStack = [];
function showModal(modalOptions) {
    let { page, props = {} } = modalOptions, options = __rest(modalOptions, ["page", "props"]);
    //Get this before any potential new frames are created by component below
    let modalLauncher = frame.topmost().currentPage;
    let componentInstanceInfo = resolveComponentElement(page, props);
    let modalView = componentInstanceInfo.element.nativeView;
    return new Promise((resolve, reject) => {
        let resolved = false;
        const closeCallback = (result) => {
            if (resolved)
                return;
            resolved = true;
            try {
                componentInstanceInfo.pageInstance.$destroy(); //don't let an exception in destroy kill the promise callback
            }
            finally {
                resolve(result);
            }
        };
        modalStack.push(componentInstanceInfo);
        modalLauncher.showModal(modalView, Object.assign({}, options, { context: {}, closeCallback }));
    });
}
function closeModal(result) {
    let modalPageInstanceInfo = modalStack.pop();
    modalPageInstanceInfo.element.nativeView.closeModal(result);
}

function installGlobalShims() {
    //expose our fake dom as global document for svelte components
    let window = global;
    window.window = global;
    window.document = new SvelteNativeDocument();
    window.requestAnimationFrame = (action) => {
        setTimeout(action, 33); //about 30 fps
    };
    window.getComputedStyle = (node) => {
        return node.nativeView.style;
    };
    window.performance = {
        now() {
            return Date.now();
        }
    };
    window.CustomEvent = class {
        constructor(name, detail = null) {
            this.eventName = name; //event name for nativescript
            this.type = name; // type for svelte
            this.detail = detail;
        }
    };
    return window.document;
}
const DomTraceCategory = 'SvelteNativeDom';
function initializeLogger() {
    logger.setHandler((message, level) => {
        let traceLevel = trace.messageType.log;
        switch (level) {
            case exports.LogLevel.Debug:
                traceLevel = trace.messageType.log;
                break;
            case exports.LogLevel.Info:
                traceLevel = trace.messageType.info;
                break;
            case exports.LogLevel.Warn:
                traceLevel = trace.messageType.warn;
                break;
            case exports.LogLevel.Error:
                traceLevel = trace.messageType.error;
                break;
        }
        trace.write(message, DomTraceCategory, traceLevel);
    });
}
function initializeDom() {
    initializeLogger();
    registerSvelteElements();
    registerNativeElements();
    return installGlobalShims();
}

exports.ActionBarElement = ActionBarElement;
exports.BottomNavigationElement = BottomNavigationElement;
exports.DomTraceCategory = DomTraceCategory;
exports.ElementNode = ElementNode;
exports.FrameElement = FrameElement;
exports.HeadElement = HeadElement;
exports.ListViewElement = ListViewElement;
exports.NativeElementNode = NativeElementNode;
exports.NativeViewElementNode = NativeViewElementNode;
exports.PageElement = PageElement;
exports.StyleElement = StyleElement;
exports.SvelteKeyedTemplate = SvelteKeyedTemplate;
exports.SvelteNativeDocument = SvelteNativeDocument;
exports.TabsElement = TabsElement;
exports.TemplateElement = TemplateElement;
exports.ViewNode = ViewNode;
exports.closeModal = closeModal;
exports.createElement = createElement;
exports.goBack = goBack;
exports.initializeDom = initializeDom;
exports.logger = logger;
exports.navigate = navigate;
exports.registerElement = registerElement;
exports.registerNativeConfigElement = registerNativeConfigElement;
exports.registerNativeViewElement = registerNativeViewElement;
exports.showModal = showModal;
