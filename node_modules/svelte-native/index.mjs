import { on, launchEvent, run } from 'tns-core-modules/application';
import { initializeDom, createElement, navigate } from './dom';
export { DomTraceCategory, closeModal, goBack, initializeDom, navigate, showModal } from './dom';

function svelteNativeNoFrame(rootElement, data) {
    initializeDom();
    return new Promise((resolve, reject) => {
        let elementInstance;
        const buildElement = () => {
            let frag = createElement('fragment');
            elementInstance = new rootElement({
                target: frag,
                props: data || {}
            });
            return frag.firstChild.nativeElement;
        };
        //wait for launch before returning
        on(launchEvent, () => {
            console.log("Application Launched");
            resolve(elementInstance);
        });
        try {
            run({ create: buildElement });
        }
        catch (e) {
            reject(e);
        }
    });
}
function svelteNative(startPage, data) {
    initializeDom();
    //setup a frame so we always have somewhere to hang our css
    let rootFrame = createElement('frame');
    rootFrame.setAttribute("id", "app-root-frame");
    let pageInstance = navigate({
        page: startPage,
        props: data || {},
        frame: rootFrame
    });
    return new Promise((resolve, reject) => {
        //wait for launch
        on(launchEvent, () => {
            console.log("Application Launched");
            resolve(pageInstance);
        });
        try {
            run({ create: () => rootFrame.nativeView });
        }
        catch (e) {
            reject(e);
        }
    });
}
// Svelte looks to see if window is undefined in order to determine if it is running on the client or in SSR.
// window is undefined until initializeDom is called. We will set it to a temporary value here and overwrite it in intializedom.
global.window = { env: "Svelte Native" };

export { svelteNative, svelteNativeNoFrame };
